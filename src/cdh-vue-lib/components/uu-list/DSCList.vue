<script lang="ts" setup>
/**
 * Special implementation of UU-List for use with the DSC backend.
 * Implements data fetching as expected from the DSC backend,
 * and configuration through a single JSON generated by DSC
 */
import { ref, computed, onMounted, watch } from "vue";
import { DataDefinedColumn, FilterDefinition, FilterValues } from "./types";
import UUList from "./UUList.vue";
import DataDefinedTable from "./Vizualizers/DDV/DataDefinedVisualizer.vue";

interface Config {
    dataUri: string;
    sortEnabled: boolean;
    sortOptions?: SortOption[];
    filtersEnabled: boolean;
    filters?: FilterDefinition[];
    pageSize: number;
    pageSizeOptions: number[];
    searchEnabled: boolean;
    columns: DataDefinedColumn[];
    container?: "default" | "sidebar";
}

interface Props {
    config: Config;
}

const props = defineProps<Props>();

interface ApiResponse {
    count: number;
    page_size: number;
    pages: number;
    results: never[];
}

interface SortOption {
    field: string;
    label: string;
}

// eslint-disable-next-line vue/no-setup-props-destructure
const pageSize = ref(props.config.pageSize);
const page = ref(1);
const search = ref("");
const sort = ref("id");
const loading = ref(true);

function createInitialFilterValues() {
    let values: FilterValues = {};

    props.config.filters?.forEach((f) => {
        if (f.initial) {
            values[f.field] = f.initial;
            return;
        }

        switch (f.type) {
            case "date":
                values[f.field] = null;
                break;
            case "checkbox":
                values[f.field] = [];
                break;
            case "radio":
                if (f.options?.length != 0 && f.options)
                    values[f.field] = f.options[0][0];
                break;
        }
    });

    return values;
}

const filterValues = ref<FilterValues>(createInitialFilterValues());

let apiData = ref<ApiResponse | null>(null);

const apiUrlArgs = computed(() => {
    let args = [];
    args.push("page_size=" + encodeURIComponent(pageSize.value));

    for (const [field, value] of Object.entries(filterValues.value)) {
        if (value == null) {
            continue;
        }
        if (typeof value === "object") {
            value.forEach((v) =>
                args.push(field + "=" + encodeURIComponent(v)),
            );
        } else {
            args.push(field + "=" + encodeURIComponent(value));
        }
    }

    if (search.value) args.push("search=" + encodeURIComponent(search.value));

    args.push("ordering=" + encodeURIComponent(sort.value));

    // eslint-disable-next-line vue/no-side-effects-in-computed-properties
    page.value = 1;

    return args;
});
const apiUrlQueryString = computed(() => {
    let args = apiUrlArgs.value;
    // Not in the method above, as that method also sets page to 1 every time
    // It's an ugly hack, but well
    let pageStr = "page=" + encodeURIComponent(page.value);
    if (args.length !== 0) pageStr = "&" + pageStr;

    return "?" + args.join("&") + pageStr;
});
const apiUrl = computed(() => {
    let url = new URL(window.location.protocol + "//" + window.location.host);
    url.pathname = props.config.dataUri;
    url.search = apiUrlQueryString.value;
    console.log(url.toString());
    return url.toString();
});

watch(apiUrl, () => {
    loadData();
});

const controller = ref<AbortController | null>(null);

function loadData() {
    // We need to create a new abort controller for every fetch request
    // So abort the old one, if it exists, and recreate a new one
    if (controller.value) controller.value.abort();
    controller.value = new AbortController();

    loading.value = true;
    fetch(apiUrl.value, { signal: controller.value.signal })
        .then((response) => {
            response.json().then((data) => {
                apiData.value = data as ApiResponse;
                loading.value = false;
                // Not strictly needed, but it's neater this way
                controller.value = null;
            });
        })
        .catch((e) => {
            console.log(e);
        });
}

onMounted(() => {
    loadData();
});
</script>

<template>
    <UUList
        :is-loading="loading"
        :data="apiData?.results ?? undefined"
        :total-data="apiData?.count ?? 0"
        :search-enabled="config.searchEnabled"
        :search="search"
        :sort-enabled="config.sortEnabled"
        :current-sort="sort"
        :page-size-options="config.pageSizeOptions"
        :sort-options="config.sortOptions ?? []"
        :page-size="apiData?.page_size ?? 10"
        :current-page="page"
        :filters-enabled="config.filtersEnabled"
        :filters="config.filters ?? []"
        :filter-values="filterValues"
        :container="config.container"
        @update:search="(value) => (search = value)"
        @update:current-sort="(value) => (sort = value)"
        @update:page-size="(value) => (pageSize = value)"
        @update:current-page="(value) => (page = value)"
        @update:filter-values="(value) => (filterValues = value)"
    >
        <template #data="{ data, isLoading }">
            <DataDefinedTable
                :data="data"
                :columns="config.columns"
                :is-loading="isLoading"
            />
        </template>
    </UUList>
</template>
